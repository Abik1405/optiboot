################################################################################
#
#  ATMEGA8 Series Pin Compatible Microcontrollers
#
#   ATMega8,   ATMega8A,
#   ATMega88,  ATMega88A,  ATMega88P,  ATMega88PA, ATMega88PB 
#   ATMega168, ATMega168A, ATMega168P, ATMega168PA, ATMega168PB
#   ATMega328, ATMega328P, ATMega328PB
#   ATMega48,  ATMega48A,  ATMega48P, ATMega48PA, ATMega48PB
#           
#  These microcontrollers are essentially pin compatible in a DIP 28 and TQFP 32
#  package, the differ mostly in memory (but not only).
#
#  The 48 and 48P are quite special cases, because they do not have a boot 
#  section of memory, so they use the VIRTUAL_BOOT function of optiboot.
#
#  A number of the updated ("A", "B") versions are not known about by 
#  avr-gcc so we are just treating them as the original version - this should
#  be fine, as long as the signature bytes are not changing (usually don't).
#
################################################################################
################################################################################
#
# Usage and General Development Notes 
# (See Further Comments for Chip Specific Notes)
#
#  WARNING: DO NOT GENERATE MULTIPLE TARGETS IN A SINGLE MAKE INVOCATION
#   DO NOT DO: `make X Y Z`
#   INSTEAD  : for i in X Y Z; do AVR_FREQ=16000000L BAUD_RATE=57600 make $i; done
#   REASON   : I hate gnu make and it hates me, if you try to do `make X Y Z` it
#              *appears* to work, but actually the generated hex files are 
#              wrong. 
#   
#     AVR_FREQ=16000000L BAUD_RATE=57600 make atmega328p
#
# to produce
#
#    optiboot_atmega328p_16000000L_57600.hex
#
# Note that if you use the _isp targets (eg atmega8_isp) the default 
# fuses are for 8MHz internal oscillator for safety.
#
# If make were easier to write for occasionally, then I'd have included suggested
# fuse values in the file names, but it's too hard (would have to look at AVR_FREQ
# and choose fuse values from a table based on that).#
#
# WHAT IS THE .TEXT and .VERSION SECTION ADDRESSES
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
# .text is the byte address of the start of the boot area, as determined by
#  your (intended) fuse settings, if we assume that the boot section is at the
#  top of the flash memory and you will use a 256 WORD (512 BYTE) boot section
#  then the address should be CONVERT_TO_HEX(TOTAL_FLASH - 512)
#
# .version is CONVERT_TO_HEX(TOTAL_FLASH - 2) 
#   - that is, the last 2 bytes of flash, I don't claim to know why, but it is
#
#  Eg: ATMega8 is 8192 bytes of Flash, we use a 256 Word Boot Area (512 Byte)
#    .text    = 8192-512 = 7680 = 0x1E00
#    .version = 8192-2   = 8190 = 0x1FFE
#
#
################################################################################







################################################################################
################################################################################
#                                                                              #
#  These are the ATMega-8 Controllers, they are essentially pin compatible     #
#  with each other and differ mainly in the amount of Memory                   #
#                                                                              #
#  At current time, I think the full list of these similar beasts is           #
#    8, 8A*, 88, 88p, 48*, 168, 168p, 328, 328p                                #
#                                                                              #
#  * the 8A has the same device signature as the 8 so they can be regarded     #
#    as identical for our purposes.                                            #
#  * has no boot section, so virtual boot mode is used                         #
#                                                                              #
################################################################################
################################################################################
# {{{

## ATMEGA328 / 328P
#  
#  328 and 328p both result in the same code, but this is only because of the 
#  fact that /usr/lib/avr/include/avr/io.h includes iom328p.h for both the 
#  varients which causes the signature bytes to ALWAYS be the 328p ones
#  
#  If that include error (feature?) is ever fixed in avr-libc then the optiboot
#  binary would be different for 328 and 328p
#
################################################################################

_atmega8_: BOOTLOADER_RESERVED = 512
_atmega8_: RESET_VECTOR = 0
_atmega8_: FEATURES += 
_atmega8_: _optiboot_

atmega328:  TARGET=atmega328
atmega328:  FLASH_SIZE=32768
atmega328:  _atmega8_

atmega328p:  TARGET=atmega328p
atmega328p:  FLASH_SIZE=32768
atmega328p:  _atmega8_

# 328pa is not known by avr-gcc, so we use 328p for MCU_TARGET
atmega328pa:  TARGET=atmega328pa
atmega328pa:  MCU_TARGET=atmega328p
atmega328pa:  FLASH_SIZE=32768
atmega328pa:  _atmega8_

# 328pb is not known by avr-gcc, so we use 328p for MCU_TARGET
atmega328pb:  TARGET=atmega328pb
atmega328pb:  MCU_TARGET=atmega328p
atmega328pb:  FLASH_SIZE=32768
atmega328pb:  _atmega8_


## ATMEGA168/168p
#  
# The 168 and 168p have different signatures, and avr/io.h treats them as 
# different chips also, so unlike the 328/328p pairing, these ones do have 
# a different binary for 168 and 168p
#
################################################################################

atmega168:  TARGET=atmega168
atmega168:  FLASH_SIZE=16384
atmega168:  _atmega8_

atmega168a:  TARGET=atmega168a
atmega168a:  FLASH_SIZE=16384
atmega168a:  _atmega8_

atmega168p:  TARGET=atmega168p
atmega168p:  FLASH_SIZE=16384
atmega168p:  _atmega8_

# 168pa is not known by avr-libc so we use 168p
atmega168pa:  TARGET=atmega168pa
atmega168pa:  MCU_TARGET=atmega168p
atmega168pa:  FLASH_SIZE=16384
atmega168pa:  _atmega8_

# 168pb is not known by avr-gcc so we use 168p
atmega168pb:  TARGET=atmega168pb
atmega168pb:  MCU_TARGET=atmega168p
atmega168pb:  FLASH_SIZE=16384
atmega168pb:  _atmega8_

## ATMEGA88/88P
#
# The 88 and 88P have different signatures, and avr/io.h treats them as 
# different chips also, so unlike the 328/328p pairing, these ones do have 
# a different binary for 88 and 88P
#
# Note that 88PA is same as 88P, use that.
#
# NB: I do not know why the -Wl,--undefined=optiboot_version option is required, 
#  I suspect it's something to do with OS/X developers.
#  On Linux, seems to be fine without but I'll leave it in anyway.
################################################################################


atmega88:  TARGET=atmega88
atmega88:  FLASH_SIZE=8192
atmega88:  _atmega8_

atmega88p:  TARGET=atmega88p
atmega88p:  FLASH_SIZE=8192
atmega88p:  _atmega8_

atmega88a:  TARGET=atmega88a
atmega88a:  FLASH_SIZE=8192
atmega88a:  _atmega8_

atmega88pa:  TARGET=atmega88pa
atmega88pa:  FLASH_SIZE=8192
atmega88pa:  _atmega8_

# 88pb is not known by avr-gcc, we use 88pa instead
atmega88pb:  TARGET=atmega88pb
atmega88pb:  MCU_TARGET = atmega88pa
atmega88pb:  FLASH_SIZE=8192
atmega88pb:  _atmega8_

## ATMEGA8
#
# The Atmega8 is similar to the Atmega88, main difference is that it doesn't have
# pin change interrupts on all the pins like the 88 so only has the two explicit
# interrupt pins and doesn't have debugWire not that Arduino users will need that.
#
# avr-gcc doesn't know about the 8A, so we target the 8 instead for that
#  yes this means that the binaries are identical and ther'es no difference
#  but one day maybe avr-gcc will treat it differently
#
# NB: I do not know why the -Wl,--undefined=optiboot_version option is required, 
#  I suspect it's something to do with OS/X developers.
#  On Linux, seems to be fine without but I'll leave it in anyway.
################################################################################

atmega8:  TARGET=atmega8
atmega8:  FLASH_SIZE=8192
atmega8:  _atmega8_

atmega8a:  TARGET=atmega8a
atmega8a:  MCU_TARGET = atmega8
atmega8a:  FLASH_SIZE=8192
atmega8a:  _atmega8_


## ATMEGA48/48P
#  
# The 48 and 48P have different signatures, and avr/io.h treats them as 
#  different chips also, so unlike the 328/328p pairing, these ones do have 
#  a different binary for 48 and 48P
#
# The 48 does not have a protected boot section of flash, so we have to use the 
#  virtual boot method of optiboot.  
#
# NOTE! In the datasheet "Interrupt vectors in ATmega48" the "Vector no." is 
#        counted 1 to 26, but we want to use the program address 0 to 25.  Sigh.
#       Hello, Atmel datasheet authors, WE PROGRAMMERS COUNT FROM FREAKING ZERO.
#
#  Vector 25 is SPM_READY, optiboot.c indicates that this is little used and is
#   the default for optiboot to use (that is, SPM_READY, not necessarily that
#   it is vector number 25).  I'm not sure that it's entirely ok to use 25...
#
#  Vector 23 is analog comparator, if 25 does funky stuff, then 23 would be a
#   good choice, few people would use the analog comparator in Arduino world.
#
# Take care to also set the fuse to enable self programming, unlike the other
#  chips you can turn this function on or off, of course we need it on!
#
# Note that you may need to adjust the --section-start if your avr-gcc compiles
# to a larger size, I have set these to have an extra 10 bytes over the sizes
# which they compiled to on my specific system, just in case in future there
# is any expansion (eh, the normal boot sections are about 10 bytes larger than
# they need to be so I figure it's a good guess).
#
# 48p/pa/pb compiles to 579 bytes without LED flashing.
#    +2 for version +1 for cal +10 for future; = 592 bytes; 4096-592=3504=0x0db0
#
# 48/a compiles to 554 bytes without LED flashing
#    +2 for version +10 for future; = 568 bytes; 4096-568=3520=0x0dca
################################################################################


_atmega48_: FLASH_SIZE   = 4092
_atmega48_: RESET_VECTOR = 25
_atmega48_: FEATURES    += VIRTUAL_BOOT_PARTITION
_atmega48_: _optiboot_

atmega48: TARGET       = atmega48
atmega48: _atmega48_

atmega48p: TARGET       = atmega48p
atmega48p: _atmega48_

# avr-libc doesn't know about the 48PA, we use 48P instead
atmega48pa: TARGET       = atmega48pa
atmega48pa: MCU_TARGET   = atmega48p
atmega48pa: _atmega48_

# avr-gcc doesn't know about the 48PB, we use 48P instead
atmega48pb: TARGET       = atmega48pb
atmega48pb: MCU_TARGET   = atmega48p
atmega48pb: _atmega48_

atmega48a: TARGET       = atmega48a
atmega48a: _atmega48_
